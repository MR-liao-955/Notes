### 合宙Air 105 学习

- C语言开发 使用Keil 编写代码

  ```c 
  
  GPIO 引脚 
  
  
  
  ```

  





- GPIO 端口的重映射

  ```c
  // 疑惑点， 关于GPIO_Remap_0 这个问题，如果不是看原理图或者 Demo的宏定义命名，根本不知道它映射的什么端口
   void GPIO_PinRemapConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, GPIO_RemapTypeDef GPIO_Remap){} // 端口映射 map 映射对象为GPIO_Remap_0、1、2、3
  
  // 目前案例中，要求是把GPIO 映射成 Uart  
  
  
  ```

  

  ![image-20230625120202959](Air105%E5%AD%A6%E4%B9%A0.assets/image-20230625120202959.png)

1



- IER 中断使能寄存器

  ```c
  // 下方截取代码部分片段，中断
      if (DISABLE != UART_FIFOInitStruct->FIFO_TX_TriggerIntEnable)
      {
          UARTx->OFFSET_4.IER |= UART_IER_PTIME;    
      }
      else
      {
          UARTx->OFFSET_4.IER &= ~UART_IER_PTIME;    
      }
  
  ```

  





- 使用 Jlink 仿真器 报错` Error: Flash* Download failed - "Cortex-M4"`

  ```bash
  # 解决经验 
  目前遇到的这个问题点在于Target 的ROM 和RAM 地址问题
  导致Jlink设备不识别Cortex 的CPU ， 因此按照官方的工程设置Target 的地址
  
  
  
  ```

  ![image-20230625171016230](Air105%E5%AD%A6%E4%B9%A0.assets/image-20230625171016230.png)



`TODO:// 读GPIO  串口   SPI `

#### TODO://

1. 按键输入， GPIO 按键输入
2. UART 串口
3. SPI 
4. I2C
5. GPIO 模拟串口，实现半双工通信







#### GPIO 按键输入

- Air105 没看到GPIO 的中断向量函数

  ```c
  // Air 105 芯片对GPIO 端口的电平操作是通过置位/复位进行操作 (而非端口寄存器)。
  void GPIO_SetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);
  void GPIO_ResetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);
  
  // 我感觉 Air105 的库没有 GPIO 的中断服务函数。
  /*
  	在使用Air105 C库开发的时候，没有GPIO 的中断，导致要监听一个按键时，需要用一个循环不断扫描它。
  
  */
  
  
  ```



- GPIO 输入函数

  ```c
  // 监听GPIO A...F 的pin 输入的数
  uint8_t GPIO_ReadInputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin); 
  
  // 监听GPIO A...F 到底是哪一个pin 在输入
  uint16_t GPIO_ReadInputData(GPIO_TypeDef* GPIOx);
  
  ```

  



#### SPI 使用

- void SPI_Init(SPI_TypeDef* SPIx, SPI_InitTypeDef* SPI_InitStruct); 函数

  ```c
  void SPI_Init(SPI_TypeDef* SPIx, SPI_InitTypeDef* SPI_InitStruct);
  
  
  
  ```

  



















































