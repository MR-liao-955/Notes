### 电子背包 Modbus 协议测试记录

[toc]

> modbus 协议参考文档

[参考文档](https://blog.csdn.net/qq_21805743/article/details/120560226)

#### 设置记录:

1. 查询设备数据

   ```bash
   # 刚开始查询的时候
   [15:29:05.545]发→◇01 03 00 01 00 0B 55 CD □
   [15:29:05.551]收←◆01 03 0B 00 00 00 00 00 FF EF A7 0C FC 00 28 77 
   
   # 发送解释
   0001 寄存器起始地址
   000B 寄存器数目
   
   # 接收解释
   0B 是字节数目
   00 00 00 00 00 FF EF A7 0C FC 00 总共 11 字节，表示 0B *2 
   28 77 检验码
   ```

2. 查询设备数据回复 ( 估计是 查询的设备 ) 但是该查询存在问题

   ```bash
   # 从机返回的错误帧， 83 是功能码， 02 (异常码 01 02 03 04)，C0F1 是返回的CRC16Modbus 校验
   [15:32:20.899]发→◇01 03 0B 01 12 34 56 78 00 05 0E 10 01 09 FA 10 □
   [15:32:20.905]收←◆01 83 02 C0 F1
   ```

   ```bash
   # 发送解释说明
   01 03 0B 01 12 34 56 78 00 05 0E 10 01 09 FA10
   0B 01 表示寄存器起始地址，固定的 2 字节。
   12 34 表示寄存器数目，1-125(0x7D),(这个值估计有问题)
   56 78 00 05 0E 10 01 09 是乱写的寄存器地址
   # 接收说明
   83 从机返回的错误帧
   02 表示异常码
   C0F1 校验码
   ```



3. 设置脉冲计数值

   ```bash
   # 设置的值为: 
   [15:42:13.810]发→◇01 10 00 02 00 02 04 12 34 56 78 09 42 □  #该条命令可重新读
   [15:42:13.816]收←◆01 10 00 02 00 02 E0 08 
   
   # 发送解释 
   00 02 表示寄存器起始地址
   00 02 表示寄存器数目
   04 字节数( N*2 字节)
   1234 5678  往寄存器中写的值 ( N*2 字节) 这里 2 个寄存器，因此为 4 字节
   09 42 校验位 CRC-16_modbus
   
   # 接收解释
   00 02 表示寄存器其实地址
   00 02 表示寄存器数目
   E0 08 表示 CRC 校验码
   ```

   ```c
   // 那我再查它一下
   01 03 00 02 00 02 65 CB
   // 回复报错， 01 83 02 C0 F1 		异常码02 不让读？
   ```

4. 设置脉冲计数值回复

   ```bash
   # 参考命令存在错误
   [16:19:14.617]发→◇01 10 00 02 00 02 E0 08 □
   [16:19:14.622]收←◆01 93 02 CD 31 
   
   # 分析原因: 因为 01 10 00 02 00 02 CRC16 
   #		  中只定义了 [0002 地址、0002 寄存器个数] 和 modbus 协议规范不符
   
   # 如果改成 01 10 00 02 00 02 04 00 00 00 00 CRC16 就能得到如下回复
   [16:21:45.161]发→◇01 10 00 02 00 02 04 00 00 00 00 72 76 □
   [16:21:45.166]收←◆01 10 00 02 00 02 E0 08 
   
   ```



5. 寄存器个数修改

   > appeui

   ```bash
   # 设置 appeui
   # 修改其 寄存器查询的个数
   # 01 10 00 1A 00 04 08 01 02 03 04 05 06 07 08 // 原始值
   01 10 00 1A 00 01 02 01 02 
   
   ```

   ```bash
   # 发送效果
   [17:10:32.525]发→◇01 10 00 1A 00 01 02 04 09 66 AC □
   [17:10:32.530]收←◆01 93 02 CD 31 
   ```

   > deveui

   ```bash
   # 原始值
   01 10 00 12 00 04 08 01 02 03 04 05 06 07 08
   
   # 修改其个数
   01 10 00 12 00 03 06 01 02 03 04 05 06  
   [17:13:10.315]发→◇01 10 00 12 00 03 06 01 02 03 04 05 06 FC 19 □
   [17:13:10.321]收←◆01 93 02 CD 31 
   ```

   > appkey

   ```bash
   # 原始值
   01 10 00 22 00 08 10 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F 01 CRC16
   
   # 修改其个数的值 
   01 10 00 22 00 03 06 01 02 03 04 05 06
   [17:17:02.855]发→◇01 10 00 22 00 03 06 01 02 03 04 05 06 FC E6 □
   [17:17:02.861]收←◆01 93 02 CD 31 
   ```

   > 时间戳

   ```bash
   # 设置时间戳 (2023-11-25 10:00:00 = 1700877600 = 0x65615520)
   01 10 00 32 00 02 04 65 61 55 20 CRC16
   # 修改其写入寄存器个数值
   01 10 00 32 00 01 02 65 61 
   [17:18:17.134]发→◇01 10 00 32 00 01 02 65 61 48 FA □
   [17:18:17.140]收←◆01 93 02 CD 31 
   ```

   > 设备上报周期

   ```bash
   # 设置设备上报周期
   01 10 00 06 00 01 02 33 33 CRC16
   
   # 修改其寄存器个数
   01 10 00 06 00 03 06 11 22 33 44 44 55
   [17:27:51.731]发→◇01 10 00 06 00 03 06 11 22 33 44 44 55 41 B7 □
   [17:27:51.738]收←◆01 93 02 CD 31 
   ```

   

   > 查找后续的 0x11 开始到 0x12 的寄存器

   ```bash
   # 查询代码
   01 03 00 11 00 02
   
   [17:31:02.370]发→◇01 03 00 11 00 02 94 0E □
   [17:31:02.375]收←◆01 03 01 00 F0 48 
   ```

   

---









