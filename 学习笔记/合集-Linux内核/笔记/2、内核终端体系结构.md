### 第2讲 Linux 内核中断体系结构

[toc]

目的：

1. 系统的中断响应 ---->内核驱动中的中断
2. 系统调用的函数响应 ( sys_call )  --->  系统调用
3. 自定义中断   -----> 软件的软中断模式 == 系统定义的方法
4. 信号中断 ( kill -signalnum ) ----> 对了解信号的使用、创建 等很有帮助
5. 系统的异常和错误  ----> 系统的异常获取 了解异常的作用。



#### 1. Linux 的中断机制

1. 分类: 硬件中断、软件中断

   硬中断: 

   - 由电脑主机的 8259A 类似的硬件中断控制芯片发出的中断
   - ARM中断控制器发出的中断

   软中断: 

   - 异常: 
     1. CPU 自行保留的中断。
     2. 系统调用异常...

2. 代码结构: 

   |                          | 中断前的处理过程，中断的恢复过程 | 中断的执行过程                  |
   | :----------------------: | -------------------------------- | ------------------------------- |
   |      硬件中断的处理      | asm.s                            | trap.c                          |
   | 软件及系统异常调用的处理 | system_call.s                    | fork.c、signal.c、exit.c、sys.c |

   

#### 2. 中断的工作流程:

1. 回顾 STM32 中断的工作流程

   - 做 CPU 工作模式的转化
   - 进行寄存器的拷贝与压栈
   - 设置中断异常向量表
   - 保存正常运行的函数返回值
   - 跳转到对应的中断服务函数上运行
   - 进行模式的复原以及寄存器的复原
   - 跳转回正常工作的函数地址继续运行

   ```bash
   # 类似于 RTOS 的 PendSV 中断，用于切换高优先级的任务。将2个指针指向低优先级工作区，执行完中断之后切换回来
   ```

2. Linux 下中断的工作流程:

   <img src="https://dearliao.oss-cn-shenzhen.aliyuncs.com/Note/picture/image-20240429001804083.png" alt="image-20240429001804083" style="zoom: 33%;" />

   > 中断前的处理过程

   1. 将所有的寄存器值入栈

      ( 8086 中 ) SS ( 栈堆寄存器 )、EFLAGS、ESP、CS、EIP ( 错误码 ) 寄存器。

      ( ARM 中 ) r0 - r15

   2. 将异常码入栈 ( 中断号 )

   3. 将当前的函数返回值进行入栈 ( 为了中断执行后能找到中断发生位置，用来复原 )

   > 中断执行过程

   4. 调用对应的中断服务函数

   > 中断后的恢复过程
   
   5. 从栈中弹出 ( 出栈 )。
   6. 返回所有入栈的寄存器值

   
   
   

#### 3. 中断的代码实现

> 阅读 asm.s 和 trap.c 代码组合

```bash
# 提前知道的知识点
1.汇编中 pushl 表示压栈
2.popl 表示出栈
3.xchgl 交换指令 eg: 'xchgl %eax,(%esp)' 

push 和pushl 在汇编都表示压栈指令，push常用于16位的汇编，pushl用于32位的汇编。区别在于压栈的数据大小和指令的用途
```

- 汇编的解释

  ```shell
  _divide_error:
  	pushl $_do_divide_error //表示把出错误的函数处理地址压入栈， _do_divide_error 是 trap.c中函数
  ```

  ![image-20240429004536979](https://dearliao.oss-cn-shenzhen.aliyuncs.com/Note/picture/image-20240429004536979.png)



- 汇编的流程压栈解释

  源码部分如图: 

  <img src="https://dearliao.oss-cn-shenzhen.aliyuncs.com/Note/picture/image-20240429004713439.png" alt="image-20240429004713439" style="zoom: 33%;" />

  ![image-20240429010525078](https://dearliao.oss-cn-shenzhen.aliyuncs.com/Note/picture/image-20240429010525078.png)

  ```shell
  #如果有错误码
  1. 先把错误码对应的函数压入栈，such: do_int3  do_int_nmi(非屏蔽中断) 这些函数都可以在traps.c中找到。
  2. 随后执行正常的压栈流程，就和 #中断流程 2.2 中的压栈顺序一样，压入所需保存的寄存器的值，以及中断(异常)的函数。
  3. iret 一个一个出栈。
  ```

  TIP: **目前未学明白，笔记做得粗糙，也没必要写那么仔细，后面学明白了之后就自然懂了。**



- 部分初始化函数解释

  > traps.c 中

  -  **set_trap_gate**   设置的权限较高，只能由用户程序调用
  -  **set_system_gate**  设置的权限较低，能由用户和系统所有的进程调用

  trap_init( ) 函数是系统进行的初始化，右边部分的参数是中断具体的执行函数。traps.c中有声明

  <img src="https://dearliao.oss-cn-shenzhen.aliyuncs.com/Note/picture/image-20240531001524175.png" alt="image-20240531001524175" style="zoom: 50%;" />

  

  > system_call.s  ---->> sys.c

  所有的系统调用 C 函数放到了统一的 sys_call_table 系统调用的操作码。

  ![image-20240531003751450](https://dearliao.oss-cn-shenzhen.aliyuncs.com/Note/picture/image-20240531003751450.png)

  &emsp;&emsp;和 asm.s 相似，执行中断调用 C 语言之前的操作。和寄存器的入栈出栈有关系，寄存器的保存和复原有关系。也与程序的数据段有关系。 

  `call _sys_call_table(,%eax,4)` %eax的每一个占位是4 

  sys_call_table[] 储存的是一堆函数指针位于 ' ./linux-0.11/include/linux/sys.h ' 中。保存了很多系统调用。

  

  等等：:laughing: 调用的这些函数名抛去 sys_ 之后是不是很眼熟？？ 这不就是 Linux 中的命令吗？比如 uname、mkdir、open、chmod....

  ![image-20240531004310527](https://dearliao.oss-cn-shenzhen.aliyuncs.com/Note/picture/image-20240531004310527.png)

  

  有关内存的知识点: 之前学 C++ 的内存分区：代码区、全局区、栈区、堆区

  <img src="https://dearliao.oss-cn-shenzhen.aliyuncs.com/Note/picture/image-20240531004823669.png" alt="image-20240531004823669" style="zoom:33%;" />

#### 4. 系统的进程管理

##### - 4.1. 系统的进程如何运转：

> 系统时间：( jiffies 系统滴答 )

:sob: CPU 内部有一个 RTC 定时器，会在上电的时候调用 mktime.c 算出从1970 年 1月1日 0:00 开始 ( 格林威治时间 ) 到当前开机点所过的秒数。

<img src="https://dearliao.oss-cn-shenzhen.aliyuncs.com/Note/picture/image-20240531005623224.png" alt="image-20240531005623224" style="zoom: 50%;" />

Linux 系统会在硬件 RTC(cmos) 中来读取当前时间，内核时间初始化代码在 ' ./linux-0.11/init/main.c '  中。

<img src="https://dearliao.oss-cn-shenzhen.aliyuncs.com/Note/picture/image-20240531011414734.png" alt="image-20240531011414734" style="zoom:50%;" />

main.c 中的 `startup_time = kernel_mktime(&time);` 计算出当前时间，并保存在 startup_time 全局变量中，并且会为 jiffies 所用。

> jiffies:
>
> 是一个系统的时钟滴答，一个系统滴答是 10ms，想象成定时器。
>
> --> 每隔 10ms 会引发一个定时器中断 (_timer_interrupt)。
>
> ----> 中断服务函数中: 进行了 jiffies 自加 ( 下方 sys_call.s 中 incl 表示自增 )。
>
> <img src="https://dearliao.oss-cn-shenzhen.aliyuncs.com/Note/picture/image-20240531013503470.png" alt="image-20240531013503470" style="zoom:50%;" />
>
> 注意 incl _jiffies 之后调用 call _do_timer。 do_time() 函数位于./linux-0.11/kernel/sched.c
>
> <img src="https://dearliao.oss-cn-shenzhen.aliyuncs.com/Note/picture/image-20240531014015249.png" alt="image-20240531014015249" style="zoom:50%;" />
>
> ```c
> // cpl：变量是内核中用来指示被中断程序的特权 0--表示内核进程  1--表示被中断的是用户进程
> // current 是一个当前进程的一个结构体对象，在内核代码中就简称进程得了。
> 	if (cpl)
> 		current->utime++; // utime 用户程序的运行时间
> 	else
> 		current->stime++; // stime 内核程序的运行时间(系统)
> 
> // next_timer 是嫁接于 jiffies 变量的所有定时器的时间链表。 (想成一颗树，每个树枝要触发的事件)
> 	if (next_timer) {
> 		next_timer->jiffies--;
> 		while (next_timer && next_timer->jiffies <= 0) {  //如果当前闹钟响了(类似于C4炸弹)，就该干活了
> 			void (*fn)(void);
> 			
> 			fn = next_timer->fn;  //
> 			next_timer->fn = NULL;
> 			next_timer = next_timer->next;
> 			(fn)();
> 		}
> 	}
> ```
>
> current->counter  ---> 进程的时间片
>
> 时间片：内核进程中的一个重要变量，标志着当前进程还能运行多长的时间。单核 CPU 只能把一个进程调用，多个进程看似并行，实则分片。
>
> > ----> counter 在哪里用？  
> >
> > 进程的调度就是 task_struck[] 进程链表的检索，找时间片最大的那个进程对象(task_struck), 然后进行调用，直到时间片为0，退出，之后再进行新一轮的调用。( 证据在 sched.c 中的 schedule( ) 函数的 counter选举中 )
>
> > ---> counter 在哪里设置
> >
> > 当全部的 task_struck[]  ( task[] ) 所有的进程的 counter 都为0，就进行新一轮的 counter 时间片分配，请看 sched.c 中 schedule( )
> >
> > 当前 0.11 内核，低版本 Linux 内核按照优先级分配, 称为： 优先级时间片轮转调度算法。
> >
> > ​		if (*p)
> > ​				(*p)->counter = ((*p)->counter >> 1) + (*p)->priority;
> >
> >  优先级大，分配到的时间片也越大



> task_struct  一个进程    task_struct[]  进程向量表 counter



---

##### - 4.2.  如何创建一个新的进程

Linux 每个进程都是一个 task_struct，所有的进程都写进 task_struct[ ] 数组中。根据 counter 来确定优先级

- sched.h 中的 task_struct 结构体

  <img src="https://dearliao.oss-cn-shenzhen.aliyuncs.com/Note/picture/image-20240604001842763.png" alt="image-20240604001842763" style="zoom: 67%;" />

  

- sched.h 中的 tss_struct 结构体。每一个进程都有如下的结构

<img src="https://dearliao.oss-cn-shenzhen.aliyuncs.com/Note/picture/image-20240604002751749.png" alt="image-20240604002751749" style="zoom: 33%;" />

<img src="https://dearliao.oss-cn-shenzhen.aliyuncs.com/Note/picture/image-20240604002506014.png" alt="image-20240604002506014" style="zoom: 50%;" />

> tss 段的作用，保存之前进程的状态。因为 CPU 在时间片轮转中会切换到别的任务，未完成的任务需要保存，以便后续轮转时执行



- 进程的状态

  系统初始化参阅 sched.c 中的 sched_init( )

  GDT 保存各类进程的指针 ( 仅保存进程的描述符 (指针)，并不保存本体)

  ![image-20240604003626189](https://dearliao.oss-cn-shenzhen.aliyuncs.com/Note/picture/image-20240604003626189.png)

  <img src="https://dearliao.oss-cn-shenzhen.aliyuncs.com/Note/picture/image-20240604004217387.png" alt="image-20240604004217387" style="zoom:67%;" />



- 进程的创建 ，./linux-0.11/init/main.c

  ![image-20240604005109721](https://dearliao.oss-cn-shenzhen.aliyuncs.com/Note/picture/image-20240604005109721.png)
  main( ) 中进行了各种外设的初始化。。创建了初始化的 0 号进程，该进程是所有进程的 "父类"

  > 内核态  === 不可抢占  (系统初始化的时候是在内核态运行的，为确保所有硬件都能成功初始化。)
  >
  > 用户态  === 可以抢占



- **在 0 号进程中：**

  1. 打开标准输入、输出、错误控制台句柄。

  2. 创建 1号进程，如果创建成功，就在一号进程执行如下

     ---> 首先打开 '/etc/rc' 文件。里面放了一些系统的配置信息。(如果你的 linux 开机要打印 LOG，可以往里面写东西)

     ---> 执行了 /bin/sh 的 shell 程序。 注意： shell 也是单独的程序

  3. **0 号进程不可能结束**，它 **只会** 在没有其它进程调用的时候执行 上图 main() 中的 `for(;;) pause();`

  ![image-20240604010723420](https://dearliao.oss-cn-shenzhen.aliyuncs.com/Note/picture/image-20240604010723420.png)





- 进程的创建:

  > fork( ) 
  >
  > 1. 在 task 链表中找一个进程空位存放当前进程。_find_empty_process
  > 2. 创建 task_struct。  fork( )
  > 3. 设置 task_struct。  copy_process(...)

  ```asm
  # system_call.s 中
  _sys_fork:
  	call _find_empty_process    #直到找到一个进程空位存放当前进程
  	testl %eax,%eax  # 测试
  	js 1f
  	push %gs 				#各种寄存器入栈
  	pushl %esi
  	pushl %edi
  	pushl %ebp
  	pushl %eax
  	call _copy_process    	# 进程复制
  	addl $20,%esp
  1:	ret
  
  
  # _find_empty_process 给当前进程分配一个进程号
  
  # ./linux-0.11/kernel/fork.c 中
  int find_empty_process(void)
  {
  	int i;
  	repeat:
  		if ((++last_pid)<0) last_pid=1;
  		for(i=0 ; i<NR_TASKS ; i++)
  			if (task[i] && task[i]->pid == last_pid) goto repeat;  //反复便利 goto 语句。
  	for(i=1 ; i<NR_TASKS ; i++)
  		if (!task[i])
  			return i;
  	return -EAGAIN;  //如果满员了，就返回错误
  }
  
  ```

  - 进程的创建就是对 0 号进程或者当前进程的复制。 ./fork.c 中 copy_process(...) 函数

    <span style="color: red;">**0 号进程复制  ---> 就是结构体的赋值 ---> 把 task[0] 对应的 task_struct 复制给新创建的 task。**</span>

  - 对于栈堆的拷贝

    <span style="color: blue;">当进程创建时要复制原有的栈堆。</span>

  - copy_process( ) 函数

    ```bash
    ## 分配空间
    	#在内核中的分配内核空间
        struct task_struct *p;
        p = (struct task_struct *) get_free_page();
    
        #理解为分配内存空间
        struct task_struct *p;
        p = (struct task_struct *) kalloc();  # kaclloc() 就是于 C中的 malloc 分配堆空间
    
    ## 堆栈的拷贝，部分和父进程一样，但是有些子进程的特性会重新赋值的。
    	*p = *current;	/* NOTE! this doesn't copy the supervisor stack */
    	p->state = TASK_UNINTERRUPTIBLE; // 不可中断状态
    	p->pid = last_pid;
    	p->father = current->pid;
    	p->counter = p->priority;
    	p->signal = 0;
    	p->alarm = 0;
    	p->leader = 0;		/* process leadership doesn't inherit */
    	p->utime = p->stime = 0;
    	p->cutime = p->cstime = 0;
    	p->start_time = jiffies;
    	p->tss.back_link = 0;
    	p->tss.esp0 = PAGE_SIZE + (long) p;
    	p->tss.ss0 = 0x10;
    	p->tss.eip = eip;
    	p->tss.eflags = eflags;
    	p->tss.eax = 0;
    	p->tss.ecx = ecx;
    	p->tss.edx = edx;
    	p->tss.ebx = ebx;
    	p->tss.esp = esp;
    	p->tss.ebp = ebp;
    	p->tss.esi = esi;
    	p->tss.edi = edi;
    	p->tss.es = es & 0xffff;
    	p->tss.cs = cs & 0xffff;
    	p->tss.ss = ss & 0xffff;
    	p->tss.ds = ds & 0xffff;
    	p->tss.fs = fs & 0xffff;
    	p->tss.gs = gs & 0xffff;
    	p->tss.ldt = _LDT(nr);
    	p->tss.trace_bitmap = 0x80000000;
    
    ## 如果进程使用了协处理器，那就设置当前创建进程的协处理器，那就设置当前创建进程的协处理器
    	# 协处理器理解为：FPU，信号处理协处理器(DSP),网络协处理器(理解为网卡)，图形协处理器(GPU)
        if (last_task_used_math == current)
        __asm__("clts ; fnsave %0"::"m" (p->tss.i387));  #such i387
    
    ## 进行老进程向新进程代码段 数据段(LDT段)  int copy_mem(int nr,struct task_struct * p)
        int copy_mem(int nr,struct task_struct * p)
        {
            unsigned long old_data_base,new_data_base,data_limit;
            unsigned long old_code_base,new_code_base,code_limit;
    
            code_limit=get_limit(0x0f);
            data_limit=get_limit(0x17);
            old_code_base = get_base(current->ldt[1]);
            old_data_base = get_base(current->ldt[2]);
            if (old_data_base != old_code_base)
                panic("We don't support separate I&D");
            if (data_limit < code_limit)
                panic("Bad data_limit");
            new_data_base = new_code_base = nr * 0x4000000;
            p->start_code = new_code_base;
            set_base(p->ldt[1],new_code_base);
            set_base(p->ldt[2],new_data_base);
            if (copy_page_tables(old_data_base,new_data_base,data_limit)) {
                free_page_tables(new_data_base,data_limit);
                return -ENOMEM;
            }
            return 0;
        }
    
    ## 继承父进程文件打开的内容。
    父进程打开的文件，子进程也会打开
    
    ## 设置进程的 tss段和 LDT段，并结合刚才拷贝过来的内容，组装成一个进程
    	set_tss_desc(gdt+(nr<<1)+FIRST_TSS_ENTRY,&(p->tss));
    	set_ldt_desc(gdt+(nr<<1)+FIRST_LDT_ENTRY,&(p->ldt));
    
    
    ## p->state = TASK_RUNNING; 给程序标志位设置为可运行状态！
    
    ## 返回进程 PID
    	return last_pid;
    
    ```

    <img src="https://dearliao.oss-cn-shenzhen.aliyuncs.com/Note/picture/image-20240604013536115.png" alt="image-20240604013536115" style="zoom:67%;" />

    **一个父进程打开了某个文件**，如果子进程继承了父进程，那么**子进程也会打开这个文件。**文件计数+1

    如上方代码

    ```c
    for (i=0; i<NR_OPEN;i++) // 父进程 打开了文件内容
    		if (f=p->filp[i])  // 打开的个数自增
    			f->f_count++;
    if (current->pwd)
        current->pwd->i_count++;
    if (current->root)
        current->root->i_count++;
    if (current->executable)
        current->executable->i_count++;
    ```

    

    

  

  







































##### - 进程调度



##### - 进程的退出



##### - 进程间通信







### 额外收获

- 学到C语言的一种写法

  ' ./linux-0.11/init/main.c ' 中的一个时间读取的函数 

  这种写法，用于防止系统时间不精准，比如 RTC(cmos) 多了1秒钟，如果当前时间不精准，那就重新读一次系统之间，直到准确为止。

  ![image-20240531011026360](https://dearliao.oss-cn-shenzhen.aliyuncs.com/Note/picture/image-20240531011026360.png)

 

> 自行理解 system_call.s 和 fork.c、signal.c、exit.c、sys.c 代码组合



