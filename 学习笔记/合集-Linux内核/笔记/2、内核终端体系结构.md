### 第2讲 Linux 内核中断体系结构

[toc]

目的：

1. 系统的中断响应 ---->内核驱动中的中断
2. 系统调用的函数响应 ( sys_call )  --->  系统调用
3. 自定义中断   -----> 软件的软中断模式 == 系统定义的方法
4. 信号中断 ( kill -signalnum ) ----> 对了解信号的使用、创建 等很有帮助
5. 系统的异常和错误  ----> 系统的异常获取 了解异常的作用。



#### 1. Linux 的中断机制

1. 分类: 硬件中断、软件中断

   硬中断: 

   - 由电脑主机的 8259A 类似的硬件中断控制芯片发出的中断
   - ARM中断控制器发出的中断

   软中断: 

   - 异常: 
     1. CPU 自行保留的中断。
     2. 系统调用异常...

2. 代码结构: 

   |                          | 中断前的处理过程，中断的恢复过程 | 中断的执行过程                  |
   | :----------------------: | -------------------------------- | ------------------------------- |
   |      硬件中断的处理      | asm.s                            | trap.c                          |
   | 软件及系统异常调用的处理 | system_call.s                    | fork.c、signal.c、exit.c、sys.c |

   

#### 2. 中断的工作流程:

1. 回顾 STM32 中断的工作流程

   - 做 CPU 工作模式的转化
   - 进行寄存器的拷贝与压栈
   - 设置中断异常向量表
   - 保存正常运行的函数返回值
   - 跳转到对应的中断服务函数上运行
   - 进行模式的复原以及寄存器的复原
   - 跳转回正常工作的函数地址继续运行

   ```bash
   # 类似于 RTOS 的 PendSV 中断，用于切换高优先级的任务。将2个指针指向低优先级工作区，执行完中断之后切换回来
   ```

2. Linux 下中断的工作流程:

   <img src="2、内核终端体系结构.assets/image-20240429001804083.png" alt="image-20240429001804083" style="zoom: 33%;" />

   > 中断前的处理过程

   1. 将所有的寄存器值入栈

      ( 8086 中 ) SS ( 栈堆寄存器 )、EFLAGS、ESP、CS、EIP ( 错误码 ) 寄存器。

      ( ARM 中 ) r0 - r15

   2. 将异常码入栈 ( 中断号 )

   3. 将当前的函数返回值进行入栈 ( 为了中断执行后能找到中断发生位置，用来复原 )

   > 中断执行过程

   4. 调用对应的中断服务函数

   > 中断后的恢复过程
   
   5. 从栈中弹出 ( 出栈 )。
   6. 返回所有入栈的寄存器值

   
   
   

#### 3. 中断的代码实现

> 阅读 asm.s 和 trap.c 代码组合

```bash
# 提前知道的知识点
1.汇编中 pushl 表示压栈
2.popl 表示出栈
3.xchgl 交换指令 eg: 'xchgl %eax,(%esp)' 

push 和pushl 在汇编都表示压栈指令，push常用于16位的汇编，pushl用于32位的汇编。区别在于压栈的数据大小和指令的用途
```

- 汇编的解释

  ```shell
  _divide_error:
  	pushl $_do_divide_error //表示把出错误的函数处理地址压入栈， _do_divide_error 是 trap.c中函数
  ```

  ![image-20240429004536979](2、内核终端体系结构.assets/image-20240429004536979.png)



- 汇编的流程压栈解释

  源码部分如图: 

  <img src="2、内核终端体系结构.assets/image-20240429004713439.png" alt="image-20240429004713439" style="zoom: 33%;" />

  ![image-20240429010525078](2、内核终端体系结构.assets/image-20240429010525078.png)

  ```shell
  #如果有错误码
  1. 先把错误码对应的函数压入栈，such: do_int3  do_int_nmi(非屏蔽中断) 这些函数都可以在traps.c中找到。
  2. 随后执行正常的压栈流程，就和 #中断流程 2.2 中的压栈顺序一样，压入所需保存的寄存器的值，以及中断(异常)的函数。
  3. iret 一个一个出栈。
  ```

  TIP: **目前未学明白，笔记做得粗糙，也没必要写那么仔细，后面学明白了之后就自然懂了。**







> 自行理解 system_call.s 和 fork.c、signal.c、exit.c、sys.c 代码组合



