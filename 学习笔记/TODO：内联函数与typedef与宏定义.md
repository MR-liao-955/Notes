### 内联函数 && typedef && macos

[toc]

#### inline 内联函数

> 原理

编译器在调用内联函数时，它会直接将函数体复制过去，而不是生成函数调用命令。因此可以减少函数调用的开销，但是会增大函数的体积。

> 何时何地使用？

- 频繁调用的函数

- 函数体比较小

  如果函数体内容较多，它会无形地导致代码膨胀，增加缓存的占用。

- 尽量写在头文件，且函数体也写进头文件，更直观。

  **关键字 `inline` 必须与函数定义体放在一起才能使函数成为内联，仅将 `inline` 放在函数声明前面不起任何作用。**

  如下风格的函数 Foo 不能成为内联函数：

  ```c++
      inline void Foo(int x, int y); // inline 仅与函数声明放在一起
      void Foo(int x, int y){}
  ```

  而如下风格的函数 Foo 则成为内联函数：

  ```c++
      void Foo(int x, int y);
  
      inline void Foo(int x, int y) {} // inline 与函数定义体放在一起
  ```

> 使用案例

- betaflight 源码中会经常调用的且对实时性要求较高的函数。

  ![image-20231229103408388](https://dearliao.oss-cn-shenzhen.aliyuncs.com/Note/picture/202401021758258.png)

  

- 内联函数在 C++ 中的应用。

  我们在定义类中，往往会把成员变量定义成私有的`private` , 这样在读写的时候会给定一个成员接口。

  此时把 **读写成员函数定义成 内联函数** 的话，它的执行效率会好很多。

  ```c++
  class Person
  {
  private:
      int age;
  public:
      inline void setAge(){}
      inline int getAge()
      {
          return age;
      }
  }
  ```



> 注意事项

- 内联函数内不允许使用 循环语句、switch语句，( 这些语句可能不会被执行 )。

- 有些函数即使声明为内联函数也不一定会被编译器内联。

  比如: 虚函数、递归函数就不会被正常内联。

- inline 仅仅是对编译器的一个建议，最后是否要内联还得看编译器的想法，如果能在调用点展开，则会形成真正的内联。

- 内联函数一定要放在函数体的地方声明 (也没必要在引用的时候声明，用户**不关心这个函数接口是否为内联的**)

  ```c
  // 正确的有效声明
  inline int test(){
      return 0;
  }
  
  // 错误的声明 (编译器不认)
  inline int test();
  ```

  

  

>  内联函数和宏定义的区别：

- 内联函数的**本质还是函数，内联只是它的一个属性而已。**
- 内联函数会检查其参数类型、返回值之类的，用法更安全。
- 内联函数会在内存中生成实体，宏定义操作的则是 token，可以进行 token 的替换和连接的操作



> `__typeof__`

- 

> 



#### typedef









#### macos 宏定义

[参考博客](https://www.jb51.net/article/276400.htm)

> 宏定义的返回值





> 宏定义展开





> do{}while(0);







#### extern 关键字